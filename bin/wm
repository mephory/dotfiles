#!/usr/bin/python2
# wm - manage dzen widgets

'''Widget Manager v1.0

Usage:
  wm list
  wm (start|stop|restart) <widget>
  wm startall
  wm stopall
  wm restartall

Options:
  -h, --help     Show this help
  -v, --version  Show version
'''
from docopt import docopt

import ConfigParser
import os
import signal
import subprocess
import shlex

def get_resolution():
    # Silence the stdout, because for some reason Xlib.protocol.request.QueryExtension
    # is printed by the Xlib.
    import sys
    from Xlib import display
    from io import StringIO

    stdout = sys.stdout
    sys.stdout = open('/dev/null', 'w');
    resolution = display.Display().screen().root.get_geometry()
    sys.stdout = stdout

    return resolution

CONFIG_FILE = os.path.join(os.getenv('HOME'), '.wmrc')
RESOLUTION = get_resolution()
# class R:
#     width = 1366
#     height = 768
# RESOLUTION = R()
#
WHITE = '\033[1;0m'
RED   = '\033[1;31m'
GREEN = '\033[1;32m'
GREY  = '\033[1;34m'

class NoSuchWidgetException(Exception):
    pass

class WidgetManager:
    def __init__(self, args):
        self.config = self._load_config()
        self.widgets = self._load_widgets()

    def widget_path(self):
        return os.path.expanduser(self.config.get('General', 'widget_path'))

    def widget_exists(self, widget_name):
        return any(map(lambda w: w.name == widget_name, self.widgets))

    def start_widget(self, widget_name):
        if not self.widget_exists(widget_name):
            raise NoSuchWidgetException()
        widget = self.get_widget(widget_name)
        widget.start()

    def stop_widget(self, widget_name):
        if not self.widget_exists(widget_name):
            raise NoSuchWidgetException()
        widget = self.get_widget(widget_name)
        widget.stop()

    def restart_widget(self, widget_name):
        if not self.widget_exists(widget_name):
            raise NoSuchWidgetException()
        widget = self.get_widget(widget_name)
        widget.restart()

    def start_all(self):
        for widget in self.widgets:
            widget.start()

    def stop_all(self):
        for widget in self.widgets:
            widget.stop()

    def restart_all(self):
        for widget in self.widgets:
            widget.restart()

    def get_widget(self, widget_name):
        return filter(lambda w: w.name == widget_name, self.widgets)[0]

    def _load_config(self):
        config = ConfigParser.ConfigParser()

        # Load default configuration
        config.add_section('General')
        config.set('General', 'widget_path', os.path.join(os.getenv('HOME'), '.widgets'))

        config.read(CONFIG_FILE)
        return config

    def list_widgets(self):
        for widget in self.widgets:
            if widget.is_running():
                status_string = '{0}[  {1}running  {0}]'.format(GREY, GREEN)
            else:
                status_string = '{0}[  {1}stopped  {0}]'.format(GREY, RED)
            print("{0:25s} {1:5s}{2}".format(widget.name, status_string, WHITE))

    def _load_widgets(self):
        widget_names = [n for n in self.config.sections() if not n == 'General']
        return map(self._load_widget, widget_names)

    def _load_widget(self, name):
        return Widget(self, name, dict(self.config.items(name)))

class Widget:
    DEFAULT_CONFIG = {
        'x':           '0',
        'y':           '0',
        'width':       '100',
        'height':      '16',
        'font':        'Terminus:size=10',
        'background':  '#212121',
        'foreground':  '#ffffff',
        'align':       'left',
        'events':      '',
        'args':        '',
    }

    def __init__(self, wm, name, config):
        self.config = dict(self.DEFAULT_CONFIG)

        self.wm = wm
        self.name = name
        self.config.update(dict(wm.config.items('General')))
        self.config.update(config)
        self._widget_proc = self._dzen_proc = None
        self._pidfile = os.path.join('/', 'tmp', 'widgetmanager', '.'.join([name, 'pid']))

    def executable_path(self):
        ''' returns the path to the executable for the widget '''
        return os.path.join(self.wm.widget_path(), self.name)

    def is_running(self):
        ''' returns True if the widget is currently running '''
        return os.path.exists(self._pidfile)

    def start(self):
        ''' starts the widget '''
        if not self.is_running():
            self._widget_proc = subprocess.Popen(self.executable_path(), stdout=subprocess.PIPE)
            self._dzen_proc = subprocess.Popen(['dzen2'] + self._dzen_args(), stdin=self._widget_proc.stdout)
            self._create_pidfile()

    def stop(self):
        ''' stops the widget '''
        try:
            if self.is_running():
                os.kill(self._dzen_pid(), signal.SIGTERM)
                os.kill(self._widget_pid(), signal.SIGTERM)
        except:
            print("Could not stop {0}".format(self.name))
        finally:
            self._remove_pidfile()

    def restart(self):
        ''' restarts the widget '''
        self.stop()
        self.start()

    @property
    def width(self):
        return self._read_config_width(self.config['width'])

    @property
    def height(self):
        return self._read_config_height(self.config['height'])

    @property
    def x(self):
        return self._read_config_x(self.config['x'])

    @property
    def y(self):
        return self._read_config_y(self.config['y'])

    @property
    def font(self):
        return self.config['font']

    @property
    def background(self):
        return self.config['background']

    @property
    def foreground(self):
        return self.config['foreground']

    @property
    def align(self):
        return self.config['align'][0]

    @property
    def events(self):
        return self.config['events']

    @property
    def args(self):
        return shlex.split(self.config['args'])

    def _dzen_args(self):
        return [ '-x', str(self.x)
               , '-w', str(self.width)
               , '-y', str(self.y)
               , '-h', str(self.height)
               , '-fn', str(self.font)
               , '-bg', str(self.background)
               , '-fg', str(self.foreground)
               , '-ta', str(self.align)
               , '-e', str(self.events)
               ] + self.args

    def _read_config_x(self, cfg_x):
        if cfg_x.lower() == 'left':
            return 0
        elif cfg_x.lower() == 'right':
            return RESOLUTION.width - self.width
        elif cfg_x.lower().startswith('leftof'):
            other_name = cfg_x.split()[1] # TODO exception
            widget = self.wm.get_widget(other_name)
            return widget.x - self.width
        elif cfg_x.lower().startswith('rightof'):
            other_name = cfg_x.split()[1] # TODO exception
            widget = self.wm.get_widget(other_name)
            return widget.x + widget.width
        else:
            return int(cfg_x)

    def _read_config_y(self, cfg_y):
        if cfg_y.lower() == 'top':
            return 0
        elif cfg_y.lower() == 'bottom':
            return RESOLUTION.height - self.height
        else:
            return int(cfg_y)

    def _read_config_width(self, cfg_w):
        if cfg_w.endswith('%'):
            perc = float(cfg_w[:-1])
            return int(perc / 100.0 * RESOLUTION.width)
        elif cfg_w == '*':
            other_widgets = filter(lambda w: w != self, self.wm.widgets)
            occupied_width = sum(map(lambda w: w.width, other_widgets))
            return RESOLUTION.width - occupied_width
        else:
            return int(cfg_w)

    def _read_config_height(self, cfg_h):
        if cfg_h.endswith('%'):
            perc = float(cfg_h[:-1])
            return int(perc / 100.0 * RESOLUTION.height)
        else:
            return int(cfg_h)

    def _create_pidfile(self):
        pidfile_dir = os.path.join('/', 'tmp', 'widgetmanager')
        if not os.path.exists(pidfile_dir):
            os.mkdir(pidfile_dir)

        with open(self._pidfile, 'w') as pidfile:
            pidfile.write("{0} {1}".format(self._widget_proc.pid, self._dzen_proc.pid))

    def _remove_pidfile(self):
        if os.path.exists(self._pidfile):
            os.remove(self._pidfile)

    def _widget_pid(self):
        with open(self._pidfile) as pidfile:
            return int(pidfile.read().split()[0])

    def _dzen_pid(self):
        with open(self._pidfile) as pidfile:
            return int(pidfile.read().split()[1])

    def __repr__(self):
        return '<Widget \'{0}\'>'.format(self.name)

if __name__ == "__main__":
    args = docopt(__doc__, version='Widget Manager v1.0')
    wm = WidgetManager(args)

    if args['list']:
        wm.list_widgets()
    elif args['start']:
        try:
            wm.start_widget(args['<widget>'])
        except NoSuchWidgetException:
            print("There is no widget called {0}. Try `wm list`.".format(args['<widget>']))
    elif args['stop']:
        try:
            wm.stop_widget(args['<widget>'])
        except NoSuchWidgetException:
            print("There is no widget called {0}. Try `wm list`.".format(args['<widget>']))
    elif args['restart']:
        try:
            wm.restart_widget(args['<widget>'])
        except NoSuchWidgetException:
            print("There is no widget called {0}. Try `wm list`.".format(args['<widget>']))
    elif args['startall']:
        wm.start_all()
    elif args['stopall']:
        wm.stop_all()
    elif args['restartall']:
        wm.restart_all()
